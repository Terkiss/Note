top priority todo

다이스 맵 생성시 기존의 정적 링크 대신 동적으로 링크
    링크의 순서

    1. wheel 을 씬에서 찾아서 세팅 -> ok 
    2. boss logo 를 씬에서 찾아서 세팅 -> ok
    3. root map object 를 세팅 -> ok
    4. boss enemy 세팅 -> ok
    5. 에네미 참조  < json 이나, 텍스트, sqllite 등을 사용 해 저장된  에네미를 사용 -> ok
    6. 유료 상자 참조 -> ok
    7. 무료 상자 참조 -> ok
    8. 버프 상자 참조 -> ok
    9. 디버프 상자 참조  -> ok
    10. 에네미 카운트 세팅 -> ok
    11. 유료 상자 카운트 세팅] -> ok
    12. 무료 상자 카운트 세팅 -> ok
    13. 버프 상자 카운트 세팅 -> ok
    14. 디버프 상자 카운트 세팅 -> ok


    15. player move controll 동적 부착 -> ok
    16. mov ability  세팅 -> ok
    17. map construct 세팅 -> ok
    18. current position 초기화 -> ok
    19. player offset position 세팅 -> ok
    20. player speed 세팅 -> ok

    21. Dices 오브젝트에 dice launch 클래스 동적 부착  -> ok
    22. dice selector -> three value dice 설정 -> ok
    23. player mov ability 클래스 연결 -> ok
    24. dice speed 세팅 -> ok
    25.  tag 세팅 -> ok
    26. diceNumEval Point 세팅  -> ok

    27. complete 시 생성 실행 (ex. mapcontsruct.loadmap()) -> ok
    28. 맵 로더 및 옵저버 로더 리펙토링 1차 -> ok



전투 의 순서
    1. 전투 관련 클래스 리뷰   ---> ok
    2. 전투 관련 클래스 리펙토링 ---> ok

    3. 전투 계측 알고리즘
    3-1. 시간을 기준으로 점수 계산
    3-2. 유닛의 생존도를 기준으로 점수 계산
    3-3. 얻어진 점수를 토대로 랭크 도입
        f -> d-> c-> b -> a -> s -> ss

 실제 전투 실행
    GameManager -> 전투의 페이스 메이킹 
    GameManager는 모든 공격을 명령이란 하나의 상위 객체로 관리. 한순간에 하나의 공격 명령 처리

    GameManager -> Command.Excute() -> 각각의 공격 명령이 실행되는 순간에 자신의 공격을 특정 시킴
    ex) -> 
    Command[] com = {command("물리"),command("마법"),command("전체"),command("전체"),command("마법"),command("물리"),command("마법")}



클라이언트 레이드의 순서 -> 추후에 변경 여지가 있다면 싱글도 바꿔야함 공격 명령 command도 변경이 필요함 
1. 멀티 플레이 를 누름 5인 레이드 선택  --> ok
2. 매치 메이킹 시작 --> ok
3. 5인의 방들중에 랜덤 입장 --> ok
4. 입장과 동시에 캐릭터 생성 서버하고도 동기화 , 이떄 마스터 클라이언트를 지정함 
5. 새로온 사람은 서버에게 데이터를 요구  
6. 요구 받은대로 생성
7. 리더를 처음 위치로 생성 or 본인을 1p 위치로 할것인지 정해야함
8. 게임은 마스터 클라이언트가 공격 명령을 인출 -> 실행 시 서버로 요청을 전송
9. 서버는 게임내 데미지 처리라던지 기타 처리를 함 
10. 서버의 처리가 끝나면 해당 매칭 hostID로 처리 결과를 return
11. 클라이언트들은 해당 처리 결과를 받아서 게임 에 반영 


레이드 버프 버튼 의 순서
1. 클라이언트가 페이즈 재화로 버프 버튼을 누름
2. 서버에게 버프를 요청 
3. 서버에서 페이즈 재화 체크 해서 결과를 리턴
4. 받은 결과에 따라 클라이언트에서 주사위를 굴림
5. 굴린 주사위 값을  서버에게 전송 
6. 서버는 전송된 값을 재화 1까고 검증후 반영 
    -> 반영 전까지 공격한 데이터에 대해선 반영하지 않음


서버의 레이드 기본 처리 순서
1. 서버는 유저가 해당 매칭에 접속시 특정 인원이 채워질떄까지 대기
2. 특정인원이 모일경우 서버는 마스터 클라이언트를 지정 함 과 동시에 변수 초기화
    -> 매칭에서 사용할 변수는 
        bool : isGameStart
        List<character> : player
        List<Enemy> : enemy
        int : abilityPoint
        int : currentPhase
        int : playTime
    
    -> 마스터 클라이언트가 도중에 게임에서 나갓을경우 라던지 일시 정지 상태에 빠졋을 경우
        현재 남아 있는 사람 들중에 마스터 클라이언트를 다시 선정 

3. 해당 매치의 마스터 클라이언트가 공격 명령 요청
     -> chrId , chrName을 둘다 받음  기본적으로 마스터 클라이언트 검사는 게속함 
4. 처리
5. 결과를 리턴 
6. 해당 레이드가 종료 될경우 방을 청소




6. 입장 한 방에서 포텐셜 avg 가 제일 높은 사람 찿기
5. avg 가 제일 높은 사람을 리더로 설정
6. 리더인 클라이언트에서 명령 생성 및 인출 작업 시작
7. 서버는 열심히 동기화
8. 최종 국면에서 보상은 서버에서 처리 



When you have time

1. 계정 마지막 접속 날짜 갱신 -> 11월 13 일 할것 

2. 포텐셜 유통기한 후 리스트 삭제

3. db 최적화 알아보기
    db 에서 받은 데이터를 서버에서 메모리 상에 전부 로딩 시키는 것은 어떻 까 ? 
    1) 현2021년 11월 12 일 시점에 어느정도 이루어짐
    2) 저장관련 메서드 만들어야함 11월 15일 예정 

4. 포텐셜에 캐릭터 등급 표시와 이름 표시 
    찾아 보기

5. 로비 에서 대표 캐릭터 선택 부분과, 싱글 플레이의 스테이지 선택에서 겟 마우스 버튼 대신 터치 이벤트를 사용 하게 끔 코드 수정 필요

6. 로비 에서 이름 수정 버튼이 대표 캐릭터로 선택 되어 졌을떄만 가능하게 수정 11월 13일 할것 


7. 재접속 했을떄 대표캐릭터 지정 -> sqlite 를 읽어서 확인후 
    sqlite를 사용 날짜 연산을 해서 24시간이 초과했다면 서버에 요청,
    요청한지 24시간이 안되었다면 내부 저장 데이터 사용
    로그아웃 하면 내부 저장 db는 초기화

8. 싱글 플레이 다이스 맵에서 주사위 가 동작 중일떄 주사위 런치 버튼의 비활성 작업 

9. Single dice map 로직 변경 필요   ---> 1차 ok 
    현 시점에서는 로딩중에 초기화 를 하고 있음
    기기 속도가 빠른 유저 일경우는 상관 없지만
    만약 느린 속도의 유저가 플레이시 초기화 가 어 긋 날 가능성이 존재함
    따라서 Sceneload manager 에게 좀더 역활을 가중 시킬 필요가 있음 

10. myownchracter 테이블에서 현재 속한 파티를 나타내는 컬럼 추가 후 로직 수정 

11. myOwnCharacter 테이블에 파티원 넘버 컬럼 추가 

12. skill info 관련 클래스 수정 및 전송 신부 json 말고 일일히 호출 형신으로 교환. json 방식더증

13. 서버 프로그램을 몇개의 프로그램을 나눌 필요가 있음
    -> 일단 나누지는 않고 일단은 해보자 

14. 서버 프로그램 리펙토링 1차 ---> ok 2021 08 

15. 칼러 피카 찿기 ---> ok  2021 08 23  

16. SingleMapLoader 클래스 리펙토링 11월 13일 예정

17. battleinfomation 클래스 리펙토링  11월 14일 예정

18. accountinfoclass 리펙토링   11월 14일 예정

19. ChrClient 클래스 리펙토링   11월 14일 예정 

20. 캐릭터 스킬 스텟 정보 클래스 리펙토링  -> 배틀 정보 클래스도 순차적으로 리펙토링  11월 14일 예정 

21. ObjectGenerator 리펙토링  필요 불 필요한 부분 발견  11월 14일 예정

22. 전투에서의 데미지 판정 함수 리펙토링    -> 클라에서 처리를 안하고 서버에 처리 

23. 전투시 이펙트 fx 대한 오브젝트 풀 구성 필요 -> 추가 고려 

24. 전투 fx 파일의 폴더 구조 변경 resourse/battlefx/meelee...
                                                 /rangel...
                                                 /party ... 등등 공격 스킬 종류에 따라 나누기 

25. 모든 자료들 폴더 구조 정리 --- ok 2021 08 25

26. 클라이언트 처리 부분을 기존 로직에서 완전히 분리 하기 
    예시 
    ChrClient.instance.xxxxController.();

27. 디비에 계정이 삭제 된 상태에서 기기로 로그인 할경우 처리 부재 -> 추후에 업데이트 


28. server 폴더 구조 변경 
    Acount -> 계정 활동 만 기록
           -> 예 회원 가입
           -> 로그인
           -> 우편함
           -> 유료 재화 무료 재화 사용
           -> 접속 시간 기록 
           -> 총 플레이 시간 기록
           -> 예정 -> 각 일자 별 플레이 시간 기록 -> 파일로 또는 sqllite 를 사용 함 

    Battle -> 전투 활동 만 기록
           -

    Player -> 게임내 일 어나는 전반적인 상황을 기록 
           -> 유저가 게임에서 일으 키는 사건 기록
           -> 유저 정보를 gameid  텍스트에 기록
           -> 게임내 결제 시스템
           -> 친구 목록
           -> 친구 매칭
           -> 랜덤 매칭
        
    
    DB     -> 데이터 저장 관련만 기록

    Object -> 유니티에서 오브젝트 생성에 대한 것만 기록

protocoll  -> 프라우드 넷에서 생성된 파일 만 기록

    server -> 서버 메인 프로그램만 기록
           -> 하위 폴더로 root command 폴더를 가짐
           rootcommand -> 최상위 관리자를 위한 명령어 만 기록



29. sql 정리 -> 문서화

30. 소프트 웨어 문서 작성 -> 아침 출근시작 후 12시까지 -> 약 30분~1시간 식 정리 
// 동적 버튼 로딩 

                button.onClick = new Button.ButtonClickedEvent();
                button.onClick.AddListener(() => {

                    var proxy = (PolyClient2Server.Proxy)ChrClient.instance.getServerProxy();


                    proxy.RequestMailReceiveCommit(Nettention.Proud.HostID.HostID_Server, Nettention.Proud.RmiContext.ReliableSend, sessionKey, JsonUtility.ToJson(item));

                    Destroy(obj);
                });
31. 서버의 로그인 세션키와 , hostid 매칭 하기 
    서버의 ServerMemory 클래스에 
    hostid -> gameid를 매칭으로 변경
    sessionkey-> allUserKey로 매칭

32. 버튼 이벤트 분리   11월 13일 ~14일 예정 

33. 2021년 11월 12일 기준 리펙토링
    버튼 -> 

34. 유니티에서 프라우드 넷에 리퀘스트 하고 결과를 받을떄 observer 패턴을 이용할 방법 생각하기
34-1. 생각한 방법 적용 하기 

35. 타이틀 화면 주사위 던지기,

36. 타이틀 왼쪽 화면으로 카메라 패스 이동 



Slungel`s Project TodoList -> complete

버스 타실
1. UI 배치

2. 버스 번호 에 따른 저장 인원 을위한 내부 데이터 베이스 수정 필요

3. 서버에서 현승객 수 가져오기;

4. 예약 탑승자수 가져오기

5. + 탑승 예약 루틴
     -> 미리 등록 한 카드로 예약 서버에 반영 

     
6. - 탑승 취소 루틴


7 탑 승 인원 / 총 인원수 * 100 ->  1 프로그래스

8 버스 전화 